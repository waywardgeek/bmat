Here's a public key encryption scheme I've come up with.

Let A be an NxN random "Boolean matrix".  For example, we could choose A =

1 1 0 0
1 0 0 1
0 1 1 1
1 1 0 1

In this case N = 4.  A required property of A is that no two rows be equal to the XOR-sum of any other rows.  For example, this matrix does not work:

1 1 0
0 1 1
1 0 1

because the first row XOR-ed with the second row equals the third row.  Over 1/5th of all random Boolean matrices had the required property, which is called being "non-singular".  Whatever.

We define "matrix multiplication" of AxB in a manner similar to normal matrix multiplication.  To compute the result in the ith row, and jth colum, you take the ith row of A and multiply it with the jth column of B.  It looks like:

res[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + ... + A[i][N-1]*B[N-1][j]

Here, I use * to mean the AND operation and + to mean XOR.  Also, you can multiply a matrix times a vertical vector, and it usually looks like:

1   1 0 1   1
0 = 1 1 0 * 1
1   0 1 0   0

In my head, I take the vector on the right, rotate it 90 degrees counter-clockwise, and AND it on the top row of the matrix.  This results in 1 0 0.  I then XOR these together to get 1, which I fill in the top row on the left.  Similarly I multiply the vector on the right times the middle row of the matrix to get the 0 in the middle on the left.

Now that we have these operations, I can define A^m = A*A*A*A... m times.  It turns out that if we choose A correctly (and I still need to figure this part out), then A^m will not be equal to A unless m == 2^(N-1) - 1:

    A^m == A implies m = 2^(N-1) - 1

So, for example, if N is 256, then we can keep multiplying m by A over and over for 2^(128) - 1 times before the result is converted back into m.  Let's also define a simple vertical N-bit vector called O (for One), that has 1 at the top and the rest 0.  For example O could be:

1
0
0
0

Here's the public key algorithm...

- Alice picks a secret random number m between 1 and 2^(N-1) - 1.
- Bob picks a secret random number n between 1 and 2^(N-1) - 1.
- Alice computes (A^m)*O (This is an N-bit vertical vector).  She transmits this publicly to Bob.
- Bob computes (A^n)*O and transmits it to Alice.
- Alice multiplies the vector from Bob by (A^m), which only she knows.  The result is (A^m)*(A^n)*O = A^(m+n)*O
- Bob multiplies the vector from Alice by (A^n), which only he knows.  The result is (A^n)*(A^m)*O = A^(m+n)*O

Now Alice and Bob both share the secret key A^(m+n)*O.  They then use this key to talk using AES or some other shared-private-key algorithm.

This can also be used for in public key encryption, where anyone can send encrypted documents to Bob anonymously, and only Bob can decrypt them.  Also, Bob can sign documents with his private key and anyone can use his public key to verify his signature.

To send an encrypted document to Bob, Alice just attaches here public key (A^m)*O to a document encrypted with the shared key.  Only Bob can decrypt it.